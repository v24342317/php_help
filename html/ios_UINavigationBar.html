<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="utf-8"/>
<title>iOS开发系列--IOS程序开发概览 - KenshinCui - 博客园</title>
<link type="text/css" rel="stylesheet" href="/bundles/blog-common.css?v=TdLMZRHMQfitXmNZ7SFinI4hbzrT2-_1PvIqhhWnsbI1"/>
<link id="MainCss" type="text/css" rel="stylesheet" href="ios_helloworld/bundle-Minyx2_Lite.css?v=box8Dmmj5G0VFMZyypCbLIqNJsuu5lz6TpJ4OOK0WkE1"/>
<link type="text/css" rel="stylesheet" href="ios_helloworld/79371.css?v=4BOS7GwZRdR90pbkyc4n7q%2fEblE%3d"/>


</head>

<body>

<div id="container">

  <div id="wrapper">
        <div id="content">
<div id="post_detail">
<div id="post" class="post">
    <a name="top"></a>
    <h2><a href="http://www.cnblogs.com/kenshincui/p/3940746.html" id="cb_post_title_url">iOS开发系列--视图切换</a></h2>
    <small>2014-08-28 08:27 by KenshinCui, <span id="post_view_count">71360</span> 阅读, <span id="post_comment_count">53</span> 评论, <a onclick="AddToWz(3940746);return false;" href="#">收藏</a>,  <a rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?postid=3940746">编辑</a></small>
    <div class="entry">
        <div id="cnblogs_post_body"><h1 id="overview">概述</h1> <p>在iOS开发中视图的切换是很频繁的，独立的视图应用在实际开发过程中并不常见，除非你的应用足够简单。在iOS开发中常用的视图切换有三种，今天我们将一一介绍：</p> <ol> <li><a href="#UITabBarController">UITabBarController</a>  </li><li><a href="#UINavigationController">UINavigationController</a>  </li><li><a href="#ModalWindow">模态窗口</a></li></ol> <h1 id="#UITabBarController">UITabBarController</h1> <p>iOS三种视图切换的原理各不相同：</p> <ul> <li>UITabBarController：以平行的方式管理视图，各个视图之间往往关系并不大，每个加入到UITabBarController的视图都会进行初始化即使当前不显示在界面上，相对比较占用内存。  </li><li>UINavigationController：以栈的方式管理视图，各个视图的切换就是压栈和出栈操作，出栈后的视图会立即销毁。  </li><li>UIModalController：以模态窗口的形式管理视图，当前视图关闭前其他视图上的内容无法操作。</li></ul> <p>UITabBarController是Apple专门为了利用页签切换视图而设计的，在这个视图控制器中有一个UITabBar控件，用户通过点击tabBar进行视图切换。我们知道在UIViewController内部有一个视图，一旦创建了UIViewController之后默认就会显示这个视图，但是UITabBarController本身并不会显示任何视图，如果要显示视图则必须设置其viewControllers属性（它默认显示viewControllers[0]）。这个属性是一个数组，它维护了所有UITabBarController的子视图。为了尽可能减少视图之间的耦合，所有的UITabBarController的子视图的相关标题、图标等信息均由子视图自己控制，UITabBarController仅仅作为一个容器存在。</p> <p><a href="ios_helloworld/280826470639328.png"><img border="0" height="520" width="800" src="ios_helloworld/280826476102429.png" alt="UITabBarControllerLayout" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" title="UITabBarControllerLayout"></a> </p> <p>假设现在有一个KCTabBarViewController（继承于UITabBarController），它内部有一个KCWebChatViewController、一个KCContactViewController。</p> <p>1.首先创建一个KCTabBarViewController继承于UITabBarController（代码是默认生成的，不再贴出来）。</p> <p>2.其次创建两个子视图，在这两个子视图控制器中设置对应的名称、图标等信息。</p> <p>KCWebChatViewController.m</p><pre class="code"><span style="color: green;">//
//  KCWorldClockViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCWebChatViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCWebChatViewController ()

@end

@implementation KCWebChatViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    self.view.backgroundColor=[UIColor redColor];
    
    </span><span style="color: green;">//设置视图控制器标题
    </span><span style="color: black;">self.title=@</span><span style="color: rgb(163, 21, 21);">"Chat"</span><span style="color: black;">;
    
    </span><span style="color: green;">//注意通过tabBarController或者parentViewController可以得到其俯视图控制器（也就是KCTabBarViewController）
    </span><span style="color: black;">NSLog(@</span><span style="color: rgb(163, 21, 21);">"%i"</span><span style="color: black;">,self.tabBarController==self.parentViewController);</span><span style="color: green;">//对于当前应用二者相等
    
    //设置图标、标题(tabBarItem是显示在tabBar上的标签)
    </span><span style="color: black;">self.tabBarItem.title=@</span><span style="color: rgb(163, 21, 21);">"Web Chat"</span><span style="color: black;">;</span><span style="color: green;">//注意如果这个标题不设置默认在页签上显示视图控制器标题
    </span><span style="color: black;">self.tabBarItem.image=[UIImage imageNamed:@</span><span style="color: rgb(163, 21, 21);">"tabbar_mainframe.png"</span><span style="color: black;">];</span><span style="color: green;">//默认图片
    </span><span style="color: black;">self.tabBarItem.selectedImage=[UIImage imageNamed:@</span><span style="color: rgb(163, 21, 21);">"tabbar_mainframeHL.png"</span><span style="color: black;">];</span><span style="color: green;">//选中图片
    
    //图标右上角内容
    </span><span style="color: black;">self.tabBarItem.badgeValue=@</span><span style="color: rgb(163, 21, 21);">"5"</span><span style="color: black;">;
    
}
@end</span></pre>
<p>KCContactViewController.m</p><pre class="code"><span style="color: green;">//
//  KCAlarmViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCContactViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCContactViewController ()

@end

@implementation KCContactViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor=[UIColor yellowColor];

    self.tabBarItem.title=@</span><span style="color: rgb(163, 21, 21);">"Contact"</span><span style="color: black;">;
    self.tabBarItem.image=[UIImage imageNamed:@</span><span style="color: rgb(163, 21, 21);">"tabbar_contacts.png"</span><span style="color: black;">];
    self.tabBarItem.selectedImage=[UIImage imageNamed:@</span><span style="color: rgb(163, 21, 21);">"tabbar_contactsHL.png"</span><span style="color: black;">];

}

@end</span></pre>
<p>3.在应用程序启动后设置Tab bar视图控制器的子视图，同时将Tab bar视图控制器作为window的根控制器。</p>
<p>AppDelegate.m</p><pre class="code"><span style="color: green;">//
//  AppDelegate.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"AppDelegate.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCTabBarViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCWebChatViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCContactViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">AppDelegate ()

@end

@implementation AppDelegate
            

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    _window=[[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
    
    KCTabBarViewController *tabBarController=[[KCTabBarViewController alloc]init];
    
    KCWebChatViewController *webChatController=[[KCWebChatViewController alloc]init];
    KCContactViewController *contactController=[[KCContactViewController alloc]init];
    tabBarController.viewControllers=@[webChatController,contactController];
    </span><span style="color: green;">//注意默认情况下UITabBarController在加载子视图时是懒加载的，所以这里调用一次contactController，否则在第一次展示时只有第一个控制器tab图标，contactController的tab图标不会显示
    </span><span style="color: blue;">for </span><span style="color: black;">(UIViewController *controller in tabBarController.viewControllers) {
        UIViewController *view= controller.view;
    }
    
    _window.rootViewController=tabBarController;
    [_window makeKeyAndVisible];
    
    </span><span style="color: blue;">return </span><span style="color: black;">YES;
}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillResignActive:(UIApplication *)application {
    </span><span style="color: green;">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationDidEnterBackground:(UIApplication *)application {
    </span><span style="color: green;">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillEnterForeground:(UIApplication *)application {
    </span><span style="color: green;">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationDidBecomeActive:(UIApplication *)application {
    </span><span style="color: green;">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillTerminate:(UIApplication *)application {
    </span><span style="color: green;">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
</span><span style="color: black;">}

@end</span></pre>
<p>运行效果：</p>
<p><a href="ios_helloworld/280826479388229.jpg"><img border="0" height="480" width="260" src="ios_helloworld/280826481731300.jpg" alt="KCWebChatViewController" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" title="KCWebChatViewController"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="ios_helloworld/280826484543086.jpg"><img border="0" height="480" width="260" src="ios_helloworld/280826487828886.jpg" alt="KCContactViewController" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" title="KCContactViewController"></a> </p>
<p>对于UITabBarController简单总结如下：</p>
<ul>
<li>UITabBarController会一次性初始化所有子控制器，但是默认只加载第一个控制器视图，其他视图控制器只初始化默认不会加载,为了能够将其他子控制器也正常显示在Tab bar中我们访问了每个子视图控制器的视图以便调用其视图加载方法（viewDidLoad）;当然，既然会调用子视图的初始化方法，当然也可以将视图控制器的tabBarItem属性设置放到init方法中设置，如此则不用再遍历其视图属性了。 
</li><li>每个视图控制器都有一个tabBarController属性，通过它可以访问所在的UITabBarController，而且对于UITabBarController的直接子视图其tabBarController等于parentViewController。 
</li><li>每个视图控制器都有一个tabBarItem属性，通过它控制视图在UITabBarController的tabBar中的显示信息。 
</li><li>tabBarItem的image属性必须是png格式（建议大小32*32）并且打开alpha通道否则无法正常显示。</li></ul>
<blockquote>
<p>注意：使用storyboard创建UITabBarController的内容今天不再着重讲解，内容比较简单，大家可以自己试验。</p></blockquote>
<h1 id="UINavigationController">UINavigationController</h1>
<h2 id="autoid-3-0-0">代码方式创建导航</h2>
<p>UINavigationController是一个导航控制器，它用来组织有层次关系的视图，在UINavigationController中子控制器以栈的形式存储，只有在栈顶的控制器能够显示在界面中，一旦一个子控制器出栈则会被销毁。UINavigationController默认也不会显示任何视图（这个控制器自身的UIView不会显示），它必须有一个根控制器rootViewController，而且这个根控制器不会像其他子控制器一样被销毁。</p>
<p><a href="ios_helloworld/280826491413931.png"><img border="0" height="500" width="800" src="ios_helloworld/280826496886031.png" alt="UINavigationControllerLayout" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" title="UINavigationControllerLayout"></a> </p>
<p>下面简单通过几个视图模拟一下微信添加好友的功能，假设有一个导航控制器，它的根控制器为好友列表控制器KCFriendViewController，通过它可以导航到添加QQ联系人视图KCQQContactViewController，在QQ联系人视图又可以导航到公共账号视图KCPublicAccountViewController。</p>
<p>1.首先在应用代理启动后初始化一个导航控制器并设置其根控制器为KCFriendViewController</p><pre class="code"><span style="color: green;">//
//  AppDelegate.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"AppDelegate.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCTabBarViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCWebChatViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCContactViewController.h"

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCFriendViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCQQContactViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">AppDelegate ()

@end

@implementation AppDelegate
            

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
    _window=[[UIWindow alloc]initWithFrame:[UIScreen mainScreen].bounds];
    
    _window.backgroundColor =[UIColor colorWithRed:249/255.0 green:249/255.0 blue:249/255.0 alpha:1];

    </span><span style="color: green;">//设置全局导航条风格和颜色
    </span><span style="color: black;">[[UINavigationBar appearance] setBarTintColor:[UIColor colorWithRed:23/255.0 green:180/255.0 blue:237/255.0 alpha:1]];
    [[UINavigationBar appearance] setBarStyle:UIBarStyleBlack];
    
    KCFriendViewController *friendController=[[KCFriendViewController alloc]init];
    UINavigationController *navigationController=[[UINavigationController alloc]initWithRootViewController:friendController];
    
    _window.rootViewController=navigationController;
    
    [_window makeKeyAndVisible];
    
    </span><span style="color: blue;">return </span><span style="color: black;">YES;
}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillResignActive:(UIApplication *)application {
    </span><span style="color: green;">// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationDidEnterBackground:(UIApplication *)application {
    </span><span style="color: green;">// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillEnterForeground:(UIApplication *)application {
    </span><span style="color: green;">// Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationDidBecomeActive:(UIApplication *)application {
    </span><span style="color: green;">// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
</span><span style="color: black;">}

- (</span><span style="color: blue;">void</span><span style="color: black;">)applicationWillTerminate:(UIApplication *)application {
    </span><span style="color: green;">// Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
</span><span style="color: black;">}

@end</span></pre>
<p>2.在好友列表视图控制器中设置导航栏左右按钮，并且设置点击右侧按钮导航到添加QQ联系人视图</p><pre class="code"><span style="color: green;">//
//  KCFriendViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCFriendViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCQQContactViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCFriendViewController ()

@end

@implementation KCFriendViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    </span><span style="color: green;">//每次出栈都会销毁相应的子控制器
    </span><span style="color: black;">NSLog(@</span><span style="color: rgb(163, 21, 21);">"childViewControllers:%@"</span><span style="color: black;">,self.navigationController.childViewControllers);
    
    </span><span style="color: green;">//在子视图中可以通过navigationController属性访问导航控制器，
    //同时对于当前子视图来说其父控制器就是其导航控制器
    </span><span style="color: black;">NSLog(@</span><span style="color: rgb(163, 21, 21);">"%i"</span><span style="color: black;">,self.navigationController==self.parentViewController);
    
    </span><span style="color: green;">//在子视图中（或者根视图）有一个navigationItem用于访问其导航信息
    </span><span style="color: black;">self.navigationItem.title=@</span><span style="color: rgb(163, 21, 21);">"Friends"</span><span style="color: black;">;</span><span style="color: green;">//或者直接设置控制器title（例如[self setTitle:@"Friends"]）
    //设置导航栏左侧按钮
    </span><span style="color: black;">self.navigationItem.leftBarButtonItem=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Edit" </span><span style="color: black;">style:UIBarButtonSystemItemAdd target:nil action:nil];
    </span><span style="color: green;">//设置导航栏右侧按钮
    </span><span style="color: black;">self.navigationItem.rightBarButtonItem=[[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@</span><span style="color: rgb(163, 21, 21);">"ff_IconAdd.png"</span><span style="color: black;">] style:UIBarButtonItemStyleDone target:self action:@selector(addFriends)];
</span><span style="color: black;">
}

-(</span><span style="color: blue;">void</span><span style="color: black;">)addFriends{
    </span><span style="color: green;">//通过push导航到另外一个子视图
    </span><span style="color: black;">KCQQContactViewController *qqContactController=[[KCQQContactViewController alloc]init];
    [self.navigationController pushViewController:qqContactController animated:YES];
}
@end</span></pre>
<p>3.在QQ联系人视图右侧导航中添加一个导航到公共账号的按钮</p><pre class="code"><span style="color: green;">//
//  KCQQContactViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCQQContactViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCPublicAccountViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCQQContactViewController ()

@end

@implementation KCQQContactViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    </span><span style="color: green;">//每次出栈都会销毁相应的子控制器
    </span><span style="color: black;">NSLog(@</span><span style="color: rgb(163, 21, 21);">"childViewControllers:%@"</span><span style="color: black;">,self.navigationController.childViewControllers);
    
    [self setTitle:@</span><span style="color: rgb(163, 21, 21);">"QQ Contact"</span><span style="color: black;">];
    </span><span style="color: green;">//self.title=@"QQ contact";
    //self.navigationItem.title=@"My QQ";
    
    </span><span style="color: black;">UIBarButtonItem *back=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"QQ" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:nil action:nil];
    self.navigationItem.backBarButtonItem=back;
    
    self.navigationItem.rightBarButtonItem=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Public Account" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(gotoNextView)];
}

-(</span><span style="color: blue;">void</span><span style="color: black;">)gotoNextView{
    KCPublicAccountViewController *publicAccountController=[[KCPublicAccountViewController alloc]init];
    [self.navigationController pushViewController:publicAccountController  animated:YES];
}
@end</span></pre>
<p>4.在公共账号视图中在导航栏右侧设置一个按钮用于直接返回根视图</p><pre class="code"><span style="color: green;">//
//  KCPublicNumberViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCPublicAccountViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCPublicAccountViewController ()

@end

@implementation KCPublicAccountViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    </span><span style="color: green;">//每次出栈都会销毁相应的子控制器
    </span><span style="color: black;">NSLog(@</span><span style="color: rgb(163, 21, 21);">"childViewControllers:%@"</span><span style="color: black;">,self.navigationController.childViewControllers);
    
    self.title=@</span><span style="color: rgb(163, 21, 21);">"Public Account"</span><span style="color: black;">;
    
    self.navigationItem.rightBarButtonItem=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Add Friends" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(gotoAddFriends)];
    
}


-(</span><span style="color: blue;">void</span><span style="color: black;">)gotoAddFriends{
    </span><span style="color: green;">//直接跳转到根控制器，也可以使用- (NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated; 方法
    </span><span style="color: black;">[self.navigationController popToRootViewControllerAnimated:YES];
}

@end</span></pre>
<ul>
<li>UINavigationController默认显示一个根控制器，这个根视图必须指定（前面我们说过UINavigationController和UITabBarController类似仅仅作为导航容器，本身并不会显示视图），通过根控制器导航到其他下一级子视图。 
</li><li>在子视图中可以通过navigationController访问导航控制器，同时可以通过navigationController的childViewControllers获得当前栈中所有的子视图（注意每一个出栈的子视图都会被销毁）。 
</li><li>UINavigationController导航是通过上方导航栏进行的（类似的UITabBarController是通过下方UITabBar进行导航），每个放到UINavigationController栈中的子视图都会显示一个导航栏，可以通过子控制器（包括根控制器）的navigationItem访问这个导航栏，修改其左右两边的按钮内容。 
</li><li>默认情况下除了根控制器之外的其他子控制器左侧都会在导航栏左侧显示返回按钮，点击可以返回上一级视图，同时按钮标题默认为上一级视图的标题,可以通过backBarButtonItem修改。下一级子视图左侧返回按钮上的标题的显示优先级为： 导航栏返回按钮backBarButtonItem的标题（注意不能直接给backBarButtonItem的标题赋值，只能重新给backBarButtonItem赋值）、导航栏navigationItem的标题，视图控制器标题。</li></ul>
<p>演示效果：</p>
<p>&nbsp;<a href="ios_helloworld/280826499854588.gif"><img src="ios_helloworld/280826522516246.gif" alt="NavigationControllerEffect" style="display: inline" title="NavigationControllerEffect"></a> </p>
<h2 id="autoid-3-1-0">使用storyboard进行导航</h2>
<p>鉴于很多初学者在学习UINavigationController时看到的多数是使用storyboard方式创建导航，而且storyboard中的segue很多初学者不是很了解，这里简单对storyboard方式创建导航进行介绍。</p>
<p>下面简单做一个类似于iOS系统设置的导航程序，系统默认进入Settings视图控制器，在Settings界面点击General进行General视图，点击Sounds进入Sounds视图，就那么简单。</p>
<p>1.首先在Main.storyboard中拖拽一个UINavigationController将应用启动箭头拖拽到新建的UINavigationController中将其作为默认启动视图，在拖拽过程中会发现UINavigationController默认会带一个UITableViewController作为其根控制器。</p>
<p>2.设置UITableViewController的标题为“Settings”，同时设置UITableView为静态表格并且包含两行，分别在两个UITableViewCell中放置一个UILabel命名为”General”和“Sounds”。</p>
<p>3.新建两个UITableViewController，标题分别设置为“General”、“Sounds”，按住Ctrl拖拽“Settings”的第一个UITableViewCell到视图控制器“General”，同时选择segue为“push”,拖拽第二个UITableViewCell到视图控制器“Sounds”，同时选择segue为“push”。</p>
<p>到这里其实我们已经可以通过Settings视图导航到General和Sounds视图了，但是storyboard是如何处理导航的呢？</p>
<p>前面我们看到导航的过程是通过一个名为“Segue”连接创建的（前面采用的是push方式），那么这个Segue是如何工作的呢？Segue的工作方式分为以下几个步骤：</p>
<p>1.创建目标视图控制器（也就是前面的General、Sounds视图控制器）</p>
<p>2.创建Segue对象</p>
<p>3.调用源视图对象的prepareForSegue:sender:方法</p>
<p>4.调用Segue对象的perform方法将目标视图控制器推送到屏幕</p>
<p>5.释放Segue对象</p>
<p>要解释上面的过程首先我们定义一个KCSettingsTableViewController控制器，它继承于UITableViewController，然后在storyboard中设置“Settings”视图控制器的class属性为KCSettingsTableViewController。同时设置导航到“General”视图控制器的segue的Identifier为“GeneralSegue”，设置导航到“Sounds”控制器的segue的Identifier为“SoundsSegue”。</p>
<p>然后修改KCSettingsTableViewController.m添加如下代码：</p><pre class="code"><span style="color: blue;">#pragma </span><span style="color: black;">mark - 导航
-(</span><span style="color: blue;">void</span><span style="color: black;">)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender{
    </span><span style="color: green;">//源视图控制器
    </span><span style="color: black;">UITableViewController *settingController=segue.sourceViewController;
    </span><span style="color: green;">//目标视图控制器
    </span><span style="color: black;">UITableViewController *tableViewController=segue.destinationViewController;
    NSLog(@</span><span style="color: rgb(163, 21, 21);">"sourceController:%@,destinationController:%@"</span><span style="color: black;">,settingController.navigationItem.title,tableViewController.navigationItem.title);
}</span></pre>
<p>此时运行程序导航我们会发现此方法会被调用的同时可以打印源视图控制器和目标视图控制器的信息，这一步对应上面所说的第三个步骤。</p>
<p>接着在”Settings”视图控制器的导航栏左右两侧分别放一个UIBarButtonItem并添加对应事件代码如下：</p><pre class="code"><span style="color: black;">- (IBAction)toGeneral:(id)sender {
    [self performSegueWithIdentifier:@</span><span style="color: rgb(163, 21, 21);">"GeneralSegue" </span><span style="color: black;">sender:self];
}

- (IBAction)toSounds:(id)sender {
    [self performSegueWithIdentifier:@</span><span style="color: rgb(163, 21, 21);">"SoundsSegue" </span><span style="color: black;">sender:self];
}</span></pre>
<p>此时运行程序发现，使用两个按钮同样可以导航到对应的视图控制器，这一步对应上面第四个步骤，只是默认情况下是自己执行的，这里我们通过手动调用来演示了这个过程。 </p>
<p>运行效果如下：</p>
<p><a href="ios_helloworld/280826527822576.gif"><img src="ios_helloworld/280826551417963.gif" alt="NavigationControllerByStoryboardEffec" style="display: inline" title="NavigationControllerByStoryboardEffec"></a> </p>
<h1 id="ModalWindow">模态窗口</h1>
<p>模态窗口只是视图控制器显示的一种方式（在iOS中并没有专门的模态窗口类），模态窗口不依赖于控制器容器（例如前两种视图切换一个依赖于UITabBarController，另一个依赖于UINavigationController），通常用于显示独立的内容，在模态窗口显示的时其他视图的内容无法进行操作。</p>
<p>模态窗口使用起来比较容易，一般的视图控制器只要调用<strong>- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion NS_AVAILABLE_IOS(5_0);</strong>方法那么参数中的视图控制器就会以模态窗口的形式展现，同时调用<strong>- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^)(void))completion NS_AVAILABLE_IOS(5_0);</strong>方法就会关闭模态窗口。</p>
<p>下面的示例中演示了一个登录操作，点击主界面左上方登录按钮以模态窗口的形式展现登录界面，用户点击登录界面中的登录按钮就会返回到主界面。特别强调一点在下面的示例中导航栏是手动创建的，而不是采用UINavigationController，为了帮助大家熟悉导航栏使用同时也了解了UInavigationController中导航栏的本质。</p>
<p>1.首先创建一个登录界面，在界面中只有两个输入框和一个登录按钮</p><pre class="code"><span style="color: green;">//
//  KCLoginViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCLoginViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCLoginViewController ()

@end

@implementation KCLoginViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    [self addLoginForm];
}

-(</span><span style="color: blue;">void</span><span style="color: black;">)addLoginForm{
    </span><span style="color: green;">//用户名
    </span><span style="color: black;">UILabel *lbUserName=[[UILabel alloc]initWithFrame:CGRectMake(50, 150, 100, 30)];
    lbUserName.text=@</span><span style="color: rgb(163, 21, 21);">"用户名："</span><span style="color: black;">;
    [self.view addSubview:lbUserName];
    
    UITextField *txtUserName=[[UITextField alloc]initWithFrame:CGRectMake(120, 150, 150, 30)];
    txtUserName.borderStyle=UITextBorderStyleRoundedRect;
    [self.view addSubview:txtUserName];
    
    </span><span style="color: green;">//密码
    </span><span style="color: black;">UILabel *lbPassword=[[UILabel alloc]initWithFrame:CGRectMake(50, 200, 100, 30)];
    lbPassword.text=@</span><span style="color: rgb(163, 21, 21);">"密码："</span><span style="color: black;">;
    [self.view addSubview:lbPassword];
    
    UITextField *txtPassword=[[UITextField alloc]initWithFrame:CGRectMake(120, 200, 150, 30)];
    txtPassword.secureTextEntry=YES;
    txtPassword.borderStyle=UITextBorderStyleRoundedRect;
    [self.view addSubview:txtPassword];
    
    </span><span style="color: green;">//登录按钮
    </span><span style="color: black;">UIButton *btnLogin=[UIButton buttonWithType:UIButtonTypeSystem];
    btnLogin.frame=CGRectMake(120, 270, 80, 30);
    [btnLogin setTitle:@</span><span style="color: rgb(163, 21, 21);">"登录" </span><span style="color: black;">forState:UIControlStateNormal];
    [self.view addSubview:btnLogin];
    [btnLogin addTarget:self action:@selector(login) forControlEvents:UIControlEventTouchUpInside];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 登录操作
-(</span><span style="color: blue;">void</span><span style="color: black;">)login{
    [self dismissViewControllerAnimated:YES completion:nil];
}


@end</span></pre>
<p>2.定义主界面视图控制器KCMainViewController，在左上角放一个登录按钮用于弹出登录界面</p><pre class="code"><span style="color: green;">//
//  KCMainViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMainViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCLoginViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCMainViewController ()

@end

@implementation KCMainViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    [self addNavigationBar];
}

</span><span style="color: black;">
</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 添加导航栏
-(</span><span style="color: blue;">void</span><span style="color: black;">)addNavigationBar{
    </span><span style="color: green;">//创建一个导航栏
    </span><span style="color: black;">UINavigationBar *navigationBar=[[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 44+20)];
    </span><span style="color: green;">//navigationBar.tintColor=[UIColor whiteColor];
    </span><span style="color: black;">[self.view addSubview:navigationBar];
    </span><span style="color: green;">//创建导航控件内容
    </span><span style="color: black;">UINavigationItem *navigationItem=[[UINavigationItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Web Chat"</span><span style="color: black;">];
    
    </span><span style="color: green;">//左侧添加登录按钮
    </span><span style="color: black;">UIBarButtonItem *loginButton=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"登录" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(login)];
    
    navigationItem.leftBarButtonItem=loginButton;
    
    </span><span style="color: green;">//添加内容到导航栏
    </span><span style="color: black;">[navigationBar pushNavigationItem:navigationItem animated:NO];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 登录操作
-(</span><span style="color: blue;">void</span><span style="color: black;">)login{
    KCLoginViewController *loginController=[[KCLoginViewController alloc]init];
    </span><span style="color: green;">//调用此方法显示模态窗口
    </span><span style="color: black;">[self presentViewController:loginController animated:YES completion:nil];
}
@end</span></pre>
<h2 id="autoid-4-0-0">参数传递</h2>
<p>假设用户名输入“kenshincui”，密码输入“123”就认为登录成功，否则登录失败。同时登录成功之后在主视图控制器中显示用户名并且登录按钮变成“注销”。要实现这个功能主要的问题就是如何把登录后的用户名信息传递到主界面？由此引出一个问题：多视图参数传递。</p>
<p>在iOS开发中常用的参数传递有以下几种方法：</p>
<ol>
<li>采用代理模式 
</li><li>采用iOS消息机制 
</li><li>通过NSDefault存储（或者文件、数据库存储等） 
</li><li>通过AppDelegate定义全局变量（或者使用UIApplication、定义一个单例类等） 
</li><li>通过控制器属性传递</li></ol>
<p>今天我们主要采用第一种方式进行数据传递，这在iOS开发中也是最常见的一种多视图传参方式。使用代理方式传递参数的步骤如下：</p>
<p>1.定义协议，协议中定义好传参时所需要的方法</p>
<p>2.目标视图控制器定义一个代理对象</p>
<p>3.源视图控制器实现协议并在初始化目标控制器时指定目标控制器的代理为其自身</p>
<p>4.需要传参的时候在目标窗口调用代理的协议方法</p>
<p>具体代码如下：</p>
<p>KCMainViewController.h</p><pre class="code"><span style="color: green;">//
//  KCMainViewController.h
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">&lt;UIKit/UIKit.h&gt;


</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 定义一个协议用于参数传递
@protocol KCMainDelegate
-(</span><span style="color: blue;">void</span><span style="color: black;">)showUserInfoWithUserName:(NSString *)userName;
@end

@</span><span style="color: blue;">interface </span><span style="color: black;">KCMainViewController : UIViewController

@end</span></pre>
<p>KCMainViewController.m</p><pre class="code"><span style="color: green;">//
//  KCMainViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMainViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCLoginViewController.h"



</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCMainViewController ()&lt;KCMainDelegate,UIActionSheetDelegate&gt;{
    UILabel *_loginInfo;
    UIBarButtonItem *_loginButton;
    BOOL _isLogon;
}

@end

@implementation KCMainViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    [self addNavigationBar];
    
    [self addLoginInfo];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 添加信息显示
-(</span><span style="color: blue;">void</span><span style="color: black;">)addLoginInfo{
    _loginInfo =[[UILabel alloc]initWithFrame:CGRectMake(0, 100,320 ,30)];
    _loginInfo.textAlignment=NSTextAlignmentCenter;
    [self.view addSubview:_loginInfo];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 添加导航栏
-(</span><span style="color: blue;">void</span><span style="color: black;">)addNavigationBar{
    </span><span style="color: green;">//创建一个导航栏
    </span><span style="color: black;">UINavigationBar *navigationBar=[[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 44+20)];
    </span><span style="color: green;">//navigationBar.tintColor=[UIColor whiteColor];
    </span><span style="color: black;">[self.view addSubview:navigationBar];
    </span><span style="color: green;">//创建导航控件内容
    </span><span style="color: black;">UINavigationItem *navigationItem=[[UINavigationItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Web Chat"</span><span style="color: black;">];
    
    </span><span style="color: green;">//左侧添加登录按钮
    </span><span style="color: black;">_loginButton=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"登录" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(login)];
    
    navigationItem.leftBarButtonItem=_loginButton;
    
    </span><span style="color: green;">//添加内容到导航栏
    </span><span style="color: black;">[navigationBar pushNavigationItem:navigationItem animated:NO];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 登录操作
-(</span><span style="color: blue;">void</span><span style="color: black;">)login{
    </span><span style="color: blue;">if </span><span style="color: black;">(!_isLogon) {
        KCLoginViewController *loginController=[[KCLoginViewController alloc]init];
        loginController.</span><span style="color: blue;">delegate</span><span style="color: black;">=self;</span><span style="color: green;">//设置代理
        //调用此方法显示模态窗口
        </span><span style="color: black;">[self presentViewController:loginController animated:YES completion:nil];
    }</span><span style="color: blue;">else</span><span style="color: black;">{
        </span><span style="color: green;">//如果登录之后则处理注销的情况
        //注意当前视图控制器必须实现UIActionSheet代理才能进行操作
        </span><span style="color: black;">UIActionSheet *actionSheet=[[UIActionSheet alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"系统信息" </span><span style="color: blue;">delegate</span><span style="color: black;">:self cancelButtonTitle:@</span><span style="color: rgb(163, 21, 21);">"取消" </span><span style="color: black;">destructiveButtonTitle:@</span><span style="color: rgb(163, 21, 21);">"注销" </span><span style="color: black;">otherButtonTitles: nil];
        [actionSheet showInView:self.view];
    }
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 实现代理方法
-(</span><span style="color: blue;">void</span><span style="color: black;">)showUserInfoWithUserName:(NSString *)userName{
    _isLogon=YES;
    </span><span style="color: green;">//显示登录用户的信息
    </span><span style="color: black;">_loginInfo.text=[NSString stringWithFormat:@</span><span style="color: rgb(163, 21, 21);">"Hello,%@!"</span><span style="color: black;">,userName];
    </span><span style="color: green;">//登录按钮内容改为“注销”
    </span><span style="color: black;">_loginButton.title=@</span><span style="color: rgb(163, 21, 21);">"注销"</span><span style="color: black;">;
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 实现注销方法
-(</span><span style="color: blue;">void</span><span style="color: black;">)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex{
    </span><span style="color: blue;">if </span><span style="color: black;">(buttonIndex==0) {</span><span style="color: green;">//注销按钮
        </span><span style="color: black;">_isLogon=NO;
        _loginButton.title=@</span><span style="color: rgb(163, 21, 21);">"登录"</span><span style="color: black;">;
        _loginInfo.text=@</span><span style="color: rgb(163, 21, 21);">""</span><span style="color: black;">;
    }
}
@end</span></pre>
<p>KCLoginViewController.h</p><pre class="code"><span style="color: green;">//
//  KCLoginViewController.h
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">&lt;UIKit/UIKit.h&gt;
</span><span style="color: black;">@protocol KCMainDelegate;

@</span><span style="color: blue;">interface </span><span style="color: black;">KCLoginViewController : UIViewController

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 定义代理
@</span><span style="color: blue;">property </span><span style="color: black;">(nonatomic,strong) id&lt;KCMainDelegate&gt; </span><span style="color: blue;">delegate</span><span style="color: black;">;

@end</span></pre>
<p>KCLoginViewController.m</p><pre class="code"><span style="color: green;">//
//  KCLoginViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCLoginViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMainViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCLoginViewController (){
    UITextField *_txtUserName;
    UITextField *_txtPassword;
}

@end

@implementation KCLoginViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    [self addLoginForm];
}

-(</span><span style="color: blue;">void</span><span style="color: black;">)addLoginForm{
    </span><span style="color: green;">//用户名
    </span><span style="color: black;">UILabel *lbUserName=[[UILabel alloc]initWithFrame:CGRectMake(50, 150, 100, 30)];
    lbUserName.text=@</span><span style="color: rgb(163, 21, 21);">"用户名："</span><span style="color: black;">;
    [self.view addSubview:lbUserName];
    
    _txtUserName=[[UITextField alloc]initWithFrame:CGRectMake(120, 150, 150, 30)];
    _txtUserName.borderStyle=UITextBorderStyleRoundedRect;
    [self.view addSubview:_txtUserName];
    
    </span><span style="color: green;">//密码
    </span><span style="color: black;">UILabel *lbPassword=[[UILabel alloc]initWithFrame:CGRectMake(50, 200, 100, 30)];
    lbPassword.text=@</span><span style="color: rgb(163, 21, 21);">"密码："</span><span style="color: black;">;
    [self.view addSubview:lbPassword];
    
    _txtPassword=[[UITextField alloc]initWithFrame:CGRectMake(120, 200, 150, 30)];
    _txtPassword.secureTextEntry=YES;
    _txtPassword.borderStyle=UITextBorderStyleRoundedRect;
    [self.view addSubview:_txtPassword];
    
    </span><span style="color: green;">//登录按钮
    </span><span style="color: black;">UIButton *btnLogin=[UIButton buttonWithType:UIButtonTypeSystem];
    btnLogin.frame=CGRectMake(70, 270, 80, 30);
    [btnLogin setTitle:@</span><span style="color: rgb(163, 21, 21);">"登录" </span><span style="color: black;">forState:UIControlStateNormal];
    [self.view addSubview:btnLogin];
    [btnLogin addTarget:self action:@selector(login) forControlEvents:UIControlEventTouchUpInside];
    
    </span><span style="color: green;">//取消登录按钮
    </span><span style="color: black;">UIButton *btnCancel=[UIButton buttonWithType:UIButtonTypeSystem];
    btnCancel.frame=CGRectMake(170, 270, 80, 30);
    [btnCancel setTitle:@</span><span style="color: rgb(163, 21, 21);">"取消" </span><span style="color: black;">forState:UIControlStateNormal];
    [self.view addSubview:btnCancel];
    [btnCancel addTarget:self action:@selector(cancel) forControlEvents:UIControlEventTouchUpInside];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 登录操作
-(</span><span style="color: blue;">void</span><span style="color: black;">)login{
    </span><span style="color: blue;">if </span><span style="color: black;">([_txtUserName.text isEqualToString:@</span><span style="color: rgb(163, 21, 21);">"kenshincui"</span><span style="color: black;">] &amp;&amp; [_txtPassword.text isEqualToString:@</span><span style="color: rgb(163, 21, 21);">"123"</span><span style="color: black;">] ) {
        </span><span style="color: green;">//调用代理方法传参
        </span><span style="color: black;">[self.</span><span style="color: blue;">delegate </span><span style="color: black;">showUserInfoWithUserName:_txtUserName.text];
        
        [self dismissViewControllerAnimated:YES completion:nil];
    }
    </span><span style="color: blue;">else</span><span style="color: black;">{
        </span><span style="color: green;">//登录失败弹出提示信息
        </span><span style="color: black;">UIAlertView *alertView=[[UIAlertView alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"系统信息" </span><span style="color: black;">message:@</span><span style="color: rgb(163, 21, 21);">"用户名或密码错误，请重新输入！" </span><span style="color: blue;">delegate</span><span style="color: black;">:nil cancelButtonTitle:@</span><span style="color: rgb(163, 21, 21);">"取消" </span><span style="color: black;">otherButtonTitles:nil];
        [alertView show];
    }
    
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 点击取消
-(</span><span style="color: blue;">void</span><span style="color: black;">)cancel{
    [self dismissViewControllerAnimated:YES completion:nil];
}

@end</span></pre>
<p>在上面的代码中，点击登录可以跳转到登录界面，如果用户名、密码输入正确可以回传参数到主界面中（不正确则给出提示），同时修改主界面按钮显示内容。如果已经登录则点击注销会弹出提示，点击确定注销则会注销登录信息。在代码中我们还用到了UIActionSheet和UIAlert，这两个控件其实也是模态窗口，只是没有铺满全屏，大家以后的开发中会经常用到。</p>
<p>假设登录之后在主视图控制器右上角点击“我”可以弹出当前用户信息如何实现呢？这个时候我们需要从主视图控制器传递参数到子视图控制器，和前面的传参刚好相反，这个时候我们通常使用上面提到的第五个方法，设置目标视图控制器的属性。</p>
<p>1.首先修改一下主视图控制器</p><pre class="code"><span style="color: green;">//
//  KCMainViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMainViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCLoginViewController.h"
</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMeViewController.h"



</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCMainViewController ()&lt;KCMainDelegate,UIActionSheetDelegate&gt;{
    UILabel *_loginInfo;
    UIBarButtonItem *_loginButton;
    UIBarButtonItem *_meButton;
    BOOL _isLogon;
}

@end

@implementation KCMainViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    [self addNavigationBar];
    
    [self addLoginInfo];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 添加信息显示
-(</span><span style="color: blue;">void</span><span style="color: black;">)addLoginInfo{
    _loginInfo =[[UILabel alloc]initWithFrame:CGRectMake(0, 100,320 ,30)];
    _loginInfo.textAlignment=NSTextAlignmentCenter;
    [self.view addSubview:_loginInfo];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 添加导航栏
-(</span><span style="color: blue;">void</span><span style="color: black;">)addNavigationBar{
    </span><span style="color: green;">//创建一个导航栏
    </span><span style="color: black;">UINavigationBar *navigationBar=[[UINavigationBar alloc]initWithFrame:CGRectMake(0, 0, 320, 44+20)];
    </span><span style="color: green;">//navigationBar.tintColor=[UIColor whiteColor];
    </span><span style="color: black;">[self.view addSubview:navigationBar];
    </span><span style="color: green;">//创建导航控件内容
    </span><span style="color: black;">UINavigationItem *navigationItem=[[UINavigationItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"Web Chat"</span><span style="color: black;">];
    
    </span><span style="color: green;">//左侧添加登录按钮
    </span><span style="color: black;">_loginButton=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"登录" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(login)];
    
    navigationItem.leftBarButtonItem=_loginButton;
    
    </span><span style="color: green;">//左侧添加导航
    </span><span style="color: black;">_meButton=[[UIBarButtonItem alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"我" </span><span style="color: black;">style:UIBarButtonItemStyleDone target:self action:@selector(showInfo)];
    _meButton.enabled=NO;
    navigationItem.rightBarButtonItem=_meButton;
    
    </span><span style="color: green;">//添加内容到导航栏
    </span><span style="color: black;">[navigationBar pushNavigationItem:navigationItem animated:NO];
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 登录操作
-(</span><span style="color: blue;">void</span><span style="color: black;">)login{
    </span><span style="color: blue;">if </span><span style="color: black;">(!_isLogon) {
        KCLoginViewController *loginController=[[KCLoginViewController alloc]init];
        loginController.</span><span style="color: blue;">delegate</span><span style="color: black;">=self;</span><span style="color: green;">//设置代理
        //调用此方法显示模态窗口
        </span><span style="color: black;">[self presentViewController:loginController animated:YES completion:nil];
    }</span><span style="color: blue;">else</span><span style="color: black;">{
        </span><span style="color: green;">//如果登录之后则处理注销的情况
        //注意必须实现对应代理
        </span><span style="color: black;">UIActionSheet *actionSheet=[[UIActionSheet alloc]initWithTitle:@</span><span style="color: rgb(163, 21, 21);">"系统信息" </span><span style="color: blue;">delegate</span><span style="color: black;">:self cancelButtonTitle:@</span><span style="color: rgb(163, 21, 21);">"取消" </span><span style="color: black;">destructiveButtonTitle:@</span><span style="color: rgb(163, 21, 21);">"注销" </span><span style="color: black;">otherButtonTitles: nil];
        [actionSheet showInView:self.view];
    }
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 点击查看我的信息
-(</span><span style="color: blue;">void</span><span style="color: black;">)showInfo{
    </span><span style="color: blue;">if </span><span style="color: black;">(_isLogon) {
        KCMeViewController *meController=[[KCMeViewController alloc]init];
        meController.userInfo=_loginInfo.text;
        [self presentViewController:meController animated:YES completion:nil];
    }
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 实现代理方法
-(</span><span style="color: blue;">void</span><span style="color: black;">)showUserInfoWithUserName:(NSString *)userName{
    _isLogon=YES;
    </span><span style="color: green;">//显示登录用户的信息
    </span><span style="color: black;">_loginInfo.text=[NSString stringWithFormat:@</span><span style="color: rgb(163, 21, 21);">"Hello,%@!"</span><span style="color: black;">,userName];
    </span><span style="color: green;">//登录按钮内容改为“注销”
    </span><span style="color: black;">_loginButton.title=@</span><span style="color: rgb(163, 21, 21);">"注销"</span><span style="color: black;">;
    _meButton.enabled=YES;
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 实现注销方法
-(</span><span style="color: blue;">void</span><span style="color: black;">)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex{
    </span><span style="color: blue;">if </span><span style="color: black;">(buttonIndex==0) {</span><span style="color: green;">//注销按钮
        </span><span style="color: black;">_isLogon=NO;
        _loginButton.title=@</span><span style="color: rgb(163, 21, 21);">"登录"</span><span style="color: black;">;
        _loginInfo.text=@</span><span style="color: rgb(163, 21, 21);">""</span><span style="color: black;">;
        _meButton.enabled=NO;
    }
}
@end</span></pre>
<p>2.添加展示用户信息的控制器视图</p>
<p>KCMeViewController.h</p><pre class="code"><span style="color: green;">//
//  KCMeViewController.h
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">&lt;UIKit/UIKit.h&gt;

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCMeViewController : UIViewController

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 需要传递的属性参数（很多时候它是一个数据模型）
@</span><span style="color: blue;">property </span><span style="color: black;">(nonatomic,copy) NSString *userInfo;

@end</span></pre>
<p>KCMeViewController.m</p><pre class="code"><span style="color: green;">//
//  KCMeViewController.m
//  ViewTransition
//
//  Created by Kenshin Cui on 14-3-15.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

</span><span style="color: blue;">#import </span><span style="color: rgb(163, 21, 21);">"KCMeViewController.h"

</span><span style="color: black;">@</span><span style="color: blue;">interface </span><span style="color: black;">KCMeViewController (){
    UILabel *_lbUserInfo;
}

@end

@implementation KCMeViewController

- (</span><span style="color: blue;">void</span><span style="color: black;">)viewDidLoad {
    [super viewDidLoad];
    
    </span><span style="color: green;">//信息显示标签
    </span><span style="color: black;">_lbUserInfo =[[UILabel alloc]initWithFrame:CGRectMake(0, 100,320 ,30)];
    _lbUserInfo.textAlignment=NSTextAlignmentCenter;
    _lbUserInfo.textColor=[UIColor colorWithRed:23/255.0 green:180/255.0 blue:237/255.0 alpha:1];
    [self.view addSubview:_lbUserInfo];
    
    </span><span style="color: green;">//关闭按钮
    </span><span style="color: black;">UIButton *btnClose=[UIButton buttonWithType:UIButtonTypeSystem];
    btnClose.frame=CGRectMake(110, 200, 100, 30);
    [btnClose setTitle:@</span><span style="color: rgb(163, 21, 21);">"关闭" </span><span style="color: black;">forState:UIControlStateNormal];
    [btnClose addTarget:self action:@selector(close) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:btnClose];
    
    </span><span style="color: green;">//设置传值信息
    </span><span style="color: black;">_lbUserInfo.text=_userInfo;
}

</span><span style="color: blue;">#pragma </span><span style="color: black;">mark 关闭
-(</span><span style="color: blue;">void</span><span style="color: black;">)close{
    [self dismissViewControllerAnimated:YES completion:nil];
}
@end</span></pre>
<p>前面代码中除了演示了模态窗口的使用还演示了两种多视图参数传递方法，其他方法日后我们再做介绍。最后完整展现一下整个示例程序：</p>
<p><a href="ios_helloworld/280826557046834.gif"><img src="ios_helloworld/280827000952811.gif" alt="ModalViewControllerEffect" style="display: inline" title="ModalViewControllerEffect"></a></p>
</div>
  

</div>

</div>

</div>

  </div>
</div>
</div>
</body>
</html>
