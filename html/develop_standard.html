<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="StyleSheet" href="../css/develop_standard/layout.css" type="text/css" />
    <link rel="StyleSheet" href="../css/develop_standard/style.css" type="text/css" />
    <style type="text/css">
        .pun, .opn, .clo {
            color: #660;
        }
    </style>
    <title>开发规范</title>
</head>
<body>
<section class="layout">
    <article  data-name="preface" class="book">
        <header>
            <h1>开发规范</h1>
            <div class="description"></div>
        </header>

        <section class="content">
            <p>开发的过程中应该尽量遵循下列命名规范：</p>

            <h2>内容列表</h2>
            <a href="#file_format">文件格式</a><br/>
            <a href="#php_closing_tag">PHP 闭合标签</a><br/>
            <a href="#class_and_method_naming">类和方法的命名</a><br/>
            <a href="#variable_names">变量命名</a><br/>
            <a href="#commenting">注释</a><br/>
            <a href="#constants">常量</a><br/>
            <a href="#true_false_and_null">TRUE, FALSE, 和NULL</a><br/>
            <a href="#logical_operators">逻辑运算符</a><br/>
            <a href="#comparing_return_values_and_typecasting">比较返回值和类型映射</a><br/>
            <a href="#debugging_code">调试代码</a><br/>
            <a href="#one_file_per_class">一个文件一个类</a><br/>
            <a href="#code_indenting">代码缩进</a><br/>
            <a href="#private_methods_and_variables">私有方法和变量</a><br/>
            <a href="#one_statement_per_line">每行一条语句</a><br/>
            <a href="#sql_queries">SQL 查询</a><br/>
            <a href="#default_function_arguments">缺省函数参数</a>

            <h2><a name="file_format"></a>文件格式</h2>

            <blockquote>
                <p>文件应该使用 <code>Unicode (UTF-8) 编码保存</code>。同时不要使用 字节序标记(BOM) 。与 UTF-16 和 UTF-32 不同，UTF-8 编码的文件不需要指明字节序，而且 字节序标记(BOM) 在PHP中会产生预期之外的输出，阻止了应用程序设置它自己的头信息。应该使用Unix 格式的行结束符(LF)。以下是在一些常见的文本编辑器中更改这些设置的方法。针对你的编辑器，方法也许会有所不同；请参考你的编辑器的说明。</p>
            </blockquote>

            <h2><a name="php_closing_tag"></a>PHP 闭合标签</h2>
            <p>PHP闭合标签“?>”在PHP中对PHP的分析器是可选的。 但是，如果使用闭合标签，任何由开发者，用户，或者FTP应用程序插入闭合标签后面的空格都有可能会引起多余的输出、php错误、之后的输出无法显示、空白页。因此，所有的php文件应该省略这个php闭合标签，并插入一段注释来标明这是文件的底部并定位这个文件在这个应用的相对路径。这样有利于你确定这个文件已经结束而不是被删节的。</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    &lt;?php<br/>
                    echo "Here's my code!";<br/>
                    ?&gt;<br/>
                    <br/>
                    <strong>适当的</strong>:<br/>
                    &lt;?php<br/>
                    echo "Here's my code!";<br/>
                    /* End of file */
                </code>
            </blockquote>

            <h2><a name="class_and_method_naming"></a>类和方法（函数）的命名规则</h2>
            <p>类名的首字母应该大写。如果名称由多个词组成，词之间要用下划线分隔，不要使用骆驼命名法。类中所有其他方法的名称应该完全小写并且名称能明确指明这个函数的用途，最好用动词开头。尽量避免过长和冗余的名称</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    class superclass<br/>
                    class SuperClass<br/>
                    <br/>
                    <strong>适当的</strong>:<br/>
                    class Super
                <br/><br/>
                class Super <br/>{<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;function __construct()<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
                <br/>
                &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                }
                </code>
            </blockquote>

            <p>不当的和适当的方法名称的示例：</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    function fileproperties()  // 方法名没有清晰的描述以及下划线分割单词<br/>
                    function fileProperties()  // 方法名没有清晰的描述以及使用了驼峰法命名<br/>
                    function getfileproperties()  // 还可以!但是忘记了下划线分割单词<br/>
                    function getFileProperties()  // 使用了驼峰法命名<br/>
                    function get_the_file_properties_from_the_file() // 方法名太冗长<br/>
                    <br/>
                    <strong>适当的</strong>:<br/>
                    function get_file_properties() // 清晰的方法名描述，下划线分割单词，全部使用小写字母</code>
            </blockquote>

            <h2><a name="variable_names"></a>变量命名</h2>
            <p>变量的命名规则与方法的命名规则十分相似。就是说，变量名应该只包含小写字母，用下划线分隔，并且能适当地指明变量的用途和内容。那些短的、无意义的变量名应该只作为迭代器用在for()循环里。</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    $j = 'foo';  // 单字符变量应该只作为for()的循环变量使用<br/>
                    $Str   // 使用了大写字母<br/>
                    $bufferedText  // 使用了驼峰命名，而且变量名应该更短，并有清晰的语法含义<br/>
                    $groupid  // 多个词组，应该使用下划线分割<br/>
                    $name_of_last_city_used // 太长了<br/>
                    <br/>
                    <strong>适当的</strong>:<br/>
                    for ($j = 0; $j &lt; 10; $j++)<br/>
                    $str<br/>
                    $buffer<br/>
                    $group_id<br/>
                    $last_city
                </code>
            </blockquote>

            <h2><a name="commenting"></a>注释</h2>
            <p>通常，代码应该被详细地注释。这不仅仅有助于给缺乏经验的程序员描述代码的流程和意图，而且有助于给你提供丰富的内容以让你在几个月后再看自己的代码时仍能很好的理解。 注释没有强制规定的格式，注释的原则是将问题解释清楚，并不是越多越好。</p>
            <blockquote>
                <code>
                    /**<br/>
                    * @name 名字<br/>
                    * @abstract 申明变量/类/方法<br/>
                    * @access 指明这个变量、类、函数/方法的存取权限<br/>
                    * @author 函数作者的名字和邮箱地址<br/>
                    * @category 组织packages<br/>
                    * @copyright 指明版权信息<br/>
                    * @const 指明常量<br/>
                    * @deprecate 指明不推荐或者是废弃的信息<br/>
                    * @example 示例<br/>
                    * @exclude 指明当前的注释将不进行分析，不出现在文挡中<br/>
                    * @final 指明这是一个最终的类、方法、属性，禁止派生、修改。<br/>
                    * @global 指明在此函数中引用的全局变量<br/>
                    * @include 指明包含的文件的信息<br/>
                    * @link 定义在线连接<br/>
                    * @module 定义归属的模块信息<br/>
                    * @modulegroup 定义归属的模块组<br/>
                    * @package 定义归属的包的信息<br/>
                    * @param 定义函数或者方法的参数信息<br/>
                    * @return 定义函数或者方法的返回信息<br/>
                    * @see 定义需要参考的函数、变量，并加入相应的超级连接。<br/>
                    * @since 指明该api函数或者方法是从哪个版本开始引入的<br/>
                    * @static 指明变量、类、函数是静态的。<br/>
                    * @throws 指明此函数可能抛出的错误异常,极其发生的情况<br/>
                    * @todo 指明应该改进或没有实现的地方<br/>
                    * @var 定义说明变量/属性。<br/>
                    * @version 定义版本信息<br/>
                    */
                </code>
            </blockquote>
            <p>类的注释</p>
            <pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class=""><code><span class="pln">/**
* 类的介绍
*
* 类的详细介绍（可选。）。
* @author  代码编写人(负责人)
* @version xx.xx  当前版本号
*/
class Test
{
}</span></code></li></ol></pre>
            <p>函数/方法注释</p>
            <pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class=""><code><span class="pln">/**
* 函数的含义说明
*
* @access public
* @param string $string //参数顺序要和函数或方法括号里的一致
* @param int $integer
* @param array $array
* @return array
*/
public function thisIsFunction($string, $integer, $array)
{return array();}  </span></code></li></ol></pre>

            <h2><a name="constants"></a>常量</h2>
            <p>常量命名除了要全部用大写外，其他的规则都和变量相同。</p>
           <blockquote>
                <code><strong>不当的</strong>:<br/>
                    myConstant // 未使用下划线分割单词，未全部使用大写字母<br/>
                    N  // 不能使用单个字母作为常量<br/>
                    S_C_VER  // 常量名没有清晰的含义<br/>
                    <br/>
                    <strong>恰当的</strong>:<br/>
                    MY_CONSTANT<br/>
                    NEWLINE<br/>
                    SUPER_CLASS_VERSION
                </code>
            </blockquote>

            <h2><a name="true_false_and_null"></a>TRUE, FALSE, 和 NULL</h2>
            <p>TRUE, FALSE, 和 NULL 关键字应该总是完全大写的。</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    if ($foo == true)<br/>
                    $bar = false;<br/>
                    function foo($bar = null)<br/>
                    <br/>
                    <strong>恰当的</strong>:<br/>
                    if ($foo == TRUE)<br/>
                    $bar = FALSE;<br/>
                    function foo($bar = NULL)</code>
            </blockquote>

            <h2><a name="logical_operators"></a>逻辑操作符</h2>
            <p>|| 有时让人底气不足，不容易辨识，因为在某些输出设备上它不够清晰(可能看起来像数字11). && 要优先于 AND ,不过两者都可以被接受, 使用 ! 时要在其前后都加一个空格。</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    if ($foo || $bar)<br/>
                    if ($foo AND $bar)  // 可以，但有时不被常用的语法程序高亮推荐(高亮标识)<br/>
                    if (!$foo)<br/>
                    if (! is_array($foo))<br/>
                    <br/>
                    <strong>恰当的</strong>:<br/>
                    if ($foo OR $bar)<br/>
                    if ($foo &amp;&amp; $bar) // 推荐<br/>
                    if ( ! $foo)<br/>
                    if ( ! is_array($foo))
                </code>
            </blockquote>

            <h2><a name="comparing_return_values_and_typecasting"></a>比较返回值与类型映射</h2>
            <p>部分PHP函数执行失败时返回 FALSE, 但也可能有一个有效的返回值 "" 或 0, 它在松散比较中会被计算为FALSE. 在条件语句中使用这些返回值的时候，为了确保返回值是你所预期的类型而不是一个有着松散类型的值，请进行显式的比较。在返回和检查你自己的变量时也要遵循这种严格的方法，必要时使用=== 和 !==。</p>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    // 如果 'foo' 位于此字符串的起始处，strpos将返回 0,<br/>
                    // 此处条件判断的结果为TRUE<br/>
                    if (strpos($str, 'foo') == FALSE)<br/>
                    <br/>
                    <strong>恰当的</strong>:<br/>
                    if (strpos($str, 'foo') === FALSE)
                </code>
            </blockquote>
            <blockquote>
                <code><strong>不当的</strong>:<br/>
                    function build_string($str = "")<br/>
                    {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if ($str == "") // uh-oh!  如果传递的参数是FALSE或者整数0那会怎么样?<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
                    <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                    }<br/>
                    <br/>
                    <strong>恰当的</strong>:<br/>
                    function build_string($str = "")<br/>
                    {<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if ($str === "")<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;{<br/>
                    <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
                    }</code>
            </blockquote>
            <p>类型映射的信息，也会非常有用。类型映射的结果稍微有些不同，但也是可用的。比如，你把一个变量映射为字符串的时候，NULL以及布尔值FALSE会变成空字符串，0(以及其它数字)变成包含数字的字符串，布尔值TRUE变成 "1".</p>
            <blockquote>
                <code>
                    $str = (string) $str; // 将 $str 映射为字符串
                </code>
            </blockquote>

            <h2><a name="debugging_code"></a>调试代码</h2>
            <p>在已提交的附加组件所在的地方不能有调试代码，它们被注释掉的情况除外，例如，创建附加组件时不能调用 var_dump(), print_r(), die(), 以及 exit() ，除非它们已经被注释掉了。</p>
            <blockquote>
                <code>
                    // print_r($foo);
                </code>
            </blockquote>

            <h2><a name="one_file_per_class"></a>一个文件一个类</h2>
            <p>对于你的附加组件所使用的类应当遵循一个文件一个类的原则，除非这些类是紧密相关的。</p>

            <h2><a name="code_indenting"></a>代码缩进</h2>
            <p>使用 Allman 风格缩进。除了类声明以外，括号总是独占一行，且缩进与“属于”它的控制语句同级。</p>
            <pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class=""><code><span class="pln"><span class="pun">不恰当的</span>:
function foo($bar) {
 // ...
}

foreach ($arr as $key => $val) {
 // ...
}

if ($foo == $bar) {
 // ...
} else {
 // ...
}

for ($i = 0; $i < 10; $i++)
{
for ($j = 0; $j < 10; $j++)
{
// ...
}
}

<span class="pun">恰当的</span>:
function foo($bar)
{
 // ...
}

foreach ($arr as $key => $val)
{
 // ...
}

if ($foo == $bar)
{
 // ...
}
else
{
 // ...
}

for ($i = 0; $i < 10; $i++)
{
    for ($j = 0; $j < 10; $j++)
    {
    // ...
    }
}
            </span></code></li></ol></pre>

            <h2><a name="private_methods_and_variables"></a>私有方法和变量</h2>
            <p>代码里像一些只是为了被类里其他公开函数所调用而封装的工具/辅助类方法，应该以一个下划线做前缀来命名。</p>
            <blockquote>
                <code>convert_text()  // 公开方法<br/>
                    _convert_text()  // 私有方法</code>
            </blockquote>

            <h2><a name="one_statement_per_line"></a>每行一条语句</h2>
            <p>切记不要在一行写多条语句</p>
            <blockquote>
                <code><strong>不正确</strong>:<br/>
                    $foo = 'this'; $bar = 'that'; $bat = str_replace($foo, $bar, $bag);<br/>
                    <br/>
                    <strong>正确</strong>:<br/>
                    $foo = 'this';<br>
                    $bar = 'that';<br>
                    $bat = str_replace($foo, $bar, $bag);
                </code>
            </blockquote>

            <h2><a name="sql_queries"></a>SQL 查询</h2>
            <p>MySQL的关键词都是大写: SELECT, INSERT, UPDATE, WHERE, AS, JOIN, ON, IN, 等。</p>
            <p>考虑到易读性，把长的查询分成多行，最好是每行只有一个从句或子从句。考虑到易读性，把长的查询分成多行，最好是每行只有一个从句或子从句。</p>
            <blockquote>
                <code><strong>不正确的</strong>: //<br> 关键词是小写并且一行中的查询太长（...表示行的继续）<br>  $query = $this-&gt;db-&gt;query("select foo, bar, baz, foofoo, foobar as raboof, foobaz from exp_pre_email_addresses ...where foo != 'oof' and baz != 'zab' order by foobaz limit 5, 100");  <br><br><strong>正确的</strong>: <br>$query = $this-&gt;db-&gt;query("SELECT foo, bar, baz, foofoo, foobar AS raboof, foobaz<br>         FROM exp_pre_email_addresses<br>         WHERE foo != 'oof'<br>         AND baz != 'zab'<br>         ORDER BY foobaz<br>         LIMIT 5, 100");</code>
            </blockquote>

            <h2><a name="default_function_arguments"></a>缺省函数参数</h2>
            <p>适当的时候，提供函数参数的缺省值，这有助于防止因错误的函数调用引起的PHP错误，另外提供常见的备选值可以节省几行代码 例如:</p>
            <blockquote>
                <code>function foo($bar = '', $baz = FALSE)</code>
            </blockquote>
        </section>
        <footer>

        </footer>
    </article>


</section>
</body>
</html>